# Работа с Git
## 1. Проверка установленного Git
В терминале выполнить команду `git version`
Если Git установлен, появится сообщение с информацией версии файла. Иначе будет сообщение об ошибке.

## 2. Установка Git.
Загружаем последнюю версию Git с сайта https://git-scm.com/downloads.
Устанавливаем с настройками по умолчанию.

## 3. Настройка Git.
При первом использовании Git необходимо представиться.
Для этого необходимо ввести в терминале две команды:
```
git config --global user.email "email@examle.com"
git config --global user.name "Ваше имя"
```
## 4. Инициализация репозитория.
Получить репозиторий можно двумя способами:
* В терминале переходим к папке, в которой хотим создать репозиторий.
Выполняем команду ` git init`
В исходной папке появится скрытая папка *.git*, содержащая все необходимые файлы репозитория - структуру Git репозитория.
* Можно *клонировать* уже существующий Git репозиторий из любого места.
## 5. Запись изменений в репозиторий.
После проделанных действий появляется Git-репозиторий и рабочая копия файлов для проекта. Нужно делать некоторые изменения и фиксировать «снимки» состояния
(snapshots) этих изменений в репозитории каждый раз, когда проект достигает
состояния, которое необходимо сохранить.
Каждый файл в рабочем каталоге может находиться в одном из двух
состояний:
* Отслеживаемые  — это те файлы, которые были в последнем снимке состояния
проекта; они могут быть неизменёнными, изменёнными или подготовленными к коммиту.
Если кратко, то отслеживаемые файлы — это те файлы, о которых знает Git.
* Неотслеживаемые — это всё остальное, любые файлы в вашем рабочем каталоге,
которые не входили в ваш последний снимок состояния и не подготовлены к коммиту.
## 6. Определение состояния файлов.
Основной инструмент, используемый для определения, какие файлы в каком состоянии
находятся — это команда `git status`. При выполнении этой команды, мы сможем увидеть что-то вроде этого: 
```
$ git status
On branch master
nothing to commit, working tree clean
```
## 7. Отслеживание новых файлов.
Для того чтобы начать отслеживать (добавить под версионный контроль) новый файл,
используется команда `git add`. Команда `git add` принимает параметром путь к файлу или каталогу,
если это каталог, команда рекурсивно добавляет все файлы из указанного каталога в
индекс.
## 8. Просмотр индексированных и неиндексированных изменений.
Для того,что узнать, что конкретно поменялось, а не только какие файлы были изменены — существует команда `git diff`. Если `git status` отвечает на эти вопросы в самом общем виде,перечисляя имена файлов, `git diff` показывает непосредственно добавленные и
удалённые строки — патч как он есть.
## 9 Коммит изменений.
После последнего раза выполнялнения команды `git status`, мы видим,что всё проиндексировано.Простейший способ зафиксировать изменения — это набрать `git commit`.
## 10. Просмотр истории коммитов.
После создания нескольких коммитов или же клонирования репозитория с уже
существующей историей коммитов, понадобится возможность посмотреть
что было сделано — историю коммитов. Одним из основных и наиболее мощных
инструментов для этого является команда `git log`.
По умолчанию (без аргументов) ``git log`` перечисляет коммиты, сделанные в репозитории в
обратном к хронологическому порядке — последние коммиты находятся вверху.

Команда ``git log`` имеет очень большое количество опций для поиска коммитов по разным
критериям. Рассмотрим наиболее популярные из них.

* Одним из самых полезных аргументов является `-p` или `--patch`, который показывает
разницу (выводит патч), внесенную в каждый коммит. Так же можно ограничить
количество записей в выводе команды, например используя параметр *`-2`* для вывода только двух записей.
Эта опция отображает аналогичную информацию но содержит разницу для каждой записи.*Очень удобно использовать данную опцию для код ревью или для быстрого просмотра
серии внесенных изменений.* 
* Так же имеется возможность использовать серию опций для
обобщения. Например, для того,чтобы увидеть сокращенную статистику для каждого
коммита, можено использовать опцию ``--stat``.
*Опция `--stat` печатает под каждым из коммитов список и количество
измененных файлов, а также сколько строк в каждом из файлов было добавлено и удалено.
В конце можно увидеть суммарную таблицу изменений.*
* Следующей действительно полезной опцией является `--pretty`. Эта опция меняет формат
вывода. Существует несколько встроенных вариантов отображения:
1. Опция *oneline* выводит
каждый коммит в одну строку, что может быть очень удобным если вы просматриваете
большое количество коммитов. К тому же, опции *short*, *full* и *fuller* делают вывод
приблизительно в том же формате, но с меньшим или большим количеством информации
соответственно:
2. Наиболее интересной опцией является *`format`*, которая позволяет указать формат для вывода
информации. Особенно это может быть полезным когда вы хотите сгенерировать вывод для автоматического анализа — так как вы указываете формат явно, он не будет изменен даже
после обновления Git
* *Полезные опции для ``git log --pretty=format`` отображает наиболее полезные опции для
изменения формата.*
## 11. Перемещение между сохранениями.
Для перемещения между сохраненными коммитами, или существующими ветками нужно использовать команду ``git checkout``.
## 12. Игнорирование файлов.
Если имеется группа файлов, которые не нужно не только автоматически
добавлять в репозиторий, но и видеть в списках неотслеживаемых - в таком случае, нужно создать файл  `.gitignore.` с перечислением
шаблонов соответствующих таким файлам. Вот пример файла `.gitignore`:
```
$ cat .gitignore
*.[oa]
*~
```
Первая строка предписывает Git игнорировать любые файлы заканчивающиеся на *«.o»* или *«.a»* — объектные и архивные файлы, которые могут появиться во время сборки кода. Вторая
строка предписывает игнорировать все файлы заканчивающиеся на тильду (~), которая
используется во многих текстовых редакторах для обозначения
временных файлов.
## 13. Создание ветки.
Чтобы создать новую ветку в Git необходимо выполнить команду 
`git branch <branch_name>`, где вместо <branch_name> будет имя вашей ветки.
После выполнения команды, будет создана новая ветка с именем, которое вы указали. Обратите внимание, что вы все еще находитесь в текущей ветке.
## 14. Слияние веток.
Основная цель создание дополнительных веток – проработать отдельный элемент проекта автономно а затем присоединить его к проекту. Поэтому в большинстве случаев эти ветки в конечном итоге объединяются с веткой master. Процедура объединения веток называется слияние (merge).

Для слияния текущей ветки с какой-либо другой используется команда `git merge <branch_name>`, где вместо `<branch_name>` будет имя созданной и отредактированной новой ветки. В результате выполнения этой команды в текущей ветке появится новый коммит. Этот коммит будет иметь два предка – последние коммиты обоих веток, участвующих в слиянии. Содержимое этого коммита будет включать содержимое коммитов обоих веток.
## 15. Конфликты при слиянии.
При слиянии может возникнуть ситуация, когда фрагмент в каком-либо файле проекта в различных ветках отредактирован по разному. Такая ситуация называется конфликт (`conflict`).

В случае возникновения конфликтов git заносит в создаваемый при объединении коммит файл, содержащий текст обеих версий.

 Начало конфликтного фрагмента помечается строкой, начинающиеся с символов `<<<<<<<` и содержащей имя первой ветки, а заканчивается строкой, начинающиеся с символов `>>>>>>>` и содержащей имя вливаемой ветки. Версии из каждой ветки разделяются строкой с символами `=======`. Такой файл получает статус не объединенный (`unmerged`).

При возникновении конфликта пользователь должен в ручном режиме его устранить. Посмотреть список не объединенных файлов можно с помощью команды ``git status``. После редактирования конфликтной области и сохранения файла, нужно сообщить git о разрешении конфликта с помощью индексирования этого файла (после чего он перейдет в состояние «измененный»).
## 16.Удаление локаальной,или удаленной ветки.

Удалить удаленную и локальную ветку из git можно следующим образом:

Для того, чтобы удалить локальную ветку, необходимо выполнить следующую команду:


```
git branch -D <branch_name>
```
`<branch_name>` название вашей локальной ветки, которую вы хотите удалить.


Для того, чтобы удалить удаленную ветку, необходимо выполнить следующую команду:
```
git push origin --delete <branch_name>
```

Аналогично примеру с удалением локальной ветки, <branch_name> является названием удаленной ветки.

Последняя команда удалит вашу ветку из репозитария и без локальной копии ветки теряютсяе все наработки в данной ветке.
## 17. Работа с удаленными репозиториями.

Для того, чтобы внести вклад в какой-либо Git-проект, необходимо уметь работать с удалёнными репозиториями. Удалённые репозитории представляют собой версии проекта, сохранённые в интернете или ещё где-то в сети. Может быть несколько удалённых репозиториев, каждый из которых может быть доступен для чтения или для чтения-записи.
Взаимодействие с другими пользователями предполагает управление удалёнными репозиториями, а также отправку и получение данных из них. Управление репозиториями включает в себя как умение добавлять новые, так и умение удалять устаревшие репозитории, а также умение управлять различными удалёнными ветками, объявлять их отслеживаемыми или нет и так далее. 

## Просмотр удалённых репозиториев

Для того, чтобы просмотреть список настроенных удалённых репозиториев, можно запустить команду ``git remote``. Она выведет названия доступных удалённых репозиториев. Если клонировать репозиторий, то можно увидить как минимум `origin` — имя по умолчанию, которое Git даёт серверу, с которого производилось клонирование

```

$ git clone  https://github.com/schacon/ticgit
Cloning into 'ticgit'...
remote: Reusing existing pack: 1857, done.
remote: Total 1857 (delta 0), reused 0 (delta 0)
Receiving objects: 100% (1857/1857), 374.35 KiB | 268.00 KiB/s, done.
Resolving deltas: 100% (772/772), done.
Checking connectivity... done.
$ cd ticgit
$ git remote
origin

```
Можно также указать ключ `-v`, чтобы просмотреть адреса для чтения и записи, привязанные к репозиторию:
```
$ git remote -v
origin	https://github.com/schacon/ticgit (fetch)
origin	https://github.com/schacon/ticgit (push)
```
Если в работе больше одного удалённого репозитория, данная команда выведет их все. Например, для репозитория с несколькими настроенными удалёнными репозиториями в случае совместной работы нескольких пользователей, вывод команды может выглядеть примерно так:

```
$ cd grit
$ git remote -v
bakkdoor  https://github.com/bakkdoor/grit (fetch)
bakkdoor  https://github.com/bakkdoor/grit (push)
cho45     https://github.com/cho45/grit (fetch)
cho45     https://github.com/cho45/grit (push)
defunkt   https://github.com/defunkt/grit (fetch)
defunkt   https://github.com/defunkt/grit (push)
koke      git://github.com/koke/grit.git (fetch)
koke      git://github.com/koke/grit.git (push)
origin    git@github.com:mojombo/grit.git (fetch)
origin    git@github.com:mojombo/grit.git (push)
```

Это означает, что можно легко получить изменения от любого из этих пользователей. 

## Добавление удалённых репозиториев.